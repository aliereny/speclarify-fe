# Speclarify FE – AI Agent Guide
## Product + Structure
- Next.js 13 App Router: routes live under src/app/...; interactive pages declare 'use client' (see src/app/page.tsx).
- Root layout wraps all pages in DashboardLayout with Ant Design shell (src/app/layout.tsx, src/ui/templates/DashboardLayout.tsx).
- Project workflow sits in src/app/projects/[projectId]/(steps) with vertical Steps navigation; keep route order consistent with layout.tsx.
- Elicitation flow is a separate upload/review loop at src/app/elicitation/page.tsx using the same card patterns.
## State & Data
- Zustand stores (src/stores) persist via localStorage; always guard SSR with useIsClient when reading store state.
- useProjectStore handles CRUD against /projects via axiosClient; API responses may omit created_at/number_of_requirements so the store injects placeholders—preserve that behavior.
- useRequirementsStore manages requirements plus duplicates/inconsistencies/ambiguities; methods refetch and re-sort by created_at to keep UI lists consistent.
- Auth tokens live in useAuthStore and flow through axios interceptors; new API calls must use axiosClient to inherit auth + refresh handling.
## Key Workflows
- Upload step (src/app/projects/[projectId]/(steps)/upload/page.tsx) relies on FileUpload; beforeUpload returns false so components must manually post FormData.
- Review step paginates five items per page and edits through ConfirmRequirementCard; wire mutations through store actions so downstream duplicate/ambiguity caches stay in sync.
- Duplicate/Inconsistency/Ambiguity steps call find* store methods and reuse card components—avoid local mutations and trigger the store refresh after deletes/updates.
- Prioritize/Classify steps update priority/class via dedicated store methods and disable saves until values change (see prioritizeRequirementCard.tsx, classifyRequirementCard.tsx).
- Export step builds download URLs from process.env.API_URL; if exposing new envs to the browser prefer NEXT_PUBLIC_* naming.
## Styling & Theming
- SCSS modules sit beside components; globals.scss defines the shared .container breakpoints and Ant Design font overrides.
- Ant Design CSS is regenerated by scripts/genAntdCss.tsx; npm run dev/build trigger pre* scripts so keep them intact when altering tokens.
## Utilities & Hooks
- useIsClient signals hydration readiness and should wrap UI that depends on browser-only globals or persisted Zustand state.
- useWindowDimensions drives responsive card layouts; reuse it instead of ad-hoc window.innerWidth checks.
## Build & Quality
- Use npm run dev for local work (runs predev to refresh public/antd.min.css) and npm run build for production checks.
- Run npm run lint before submitting changes; this is the current automated quality gate.
## Definition of Done
- Every task must include unit tests; add or extend a React-friendly runner (Jest/Vitest) as part of the change until a shared setup exists.
- Always execute the full test suite after your updates (add an npm script if missing) and rerun npm run lint.
## Implementation Notes
- Keep new UI in ui/atoms|molecules|organisms to stay consistent; reuse existing cards/forms when possible.
- Place network helpers in src/services as thin wrappers around axiosClient; avoid direct axios usage in components.
- When evolving stores, update the persisted shape carefully to avoid breaking existing storage keys (auth-storage, projects, requirements).
- Prefer Ant Design feedback primitives (message, Alert, Skeleton) for async UX to match the rest of the app.
